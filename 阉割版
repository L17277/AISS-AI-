import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, simpledialog
import random
import time
import threading
import json
import os
from datetime import datetime
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.font_manager as fm

# è®¾ç½®ä¸­æ–‡å­—ä½“ - ä¿®å¤å­—ä½“é—®é¢˜
def setup_chinese_font():
    """è®¾ç½®ä¸­æ–‡å­—ä½“æ”¯æŒ"""
    # å°è¯•ä½¿ç”¨ç³»ç»Ÿä¸­å¯ç”¨çš„ä¸­æ–‡å­—ä½“
    chinese_fonts = ['SimHei', 'Microsoft YaHei', 'KaiTi', 'SimSun', 'FangSong']
    available_fonts = []
    
    for font in chinese_fonts:
        try:
            if fm.findfont(font):
                available_fonts.append(font)
        except:
            continue
    
    if available_fonts:
        plt.rcParams['font.sans-serif'] = available_fonts + ['DejaVu Sans']
        plt.rcParams['axes.unicode_minus'] = False
        return available_fonts[0]
    else:
        # å¦‚æœæ²¡æœ‰ä¸­æ–‡å­—ä½“ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“
        plt.rcParams['font.sans-serif'] = ['DejaVu Sans']
        return 'DejaVu Sans'

# åˆå§‹åŒ–å­—ä½“
chinese_font = setup_chinese_font()

@dataclass
class Resource:
    """èµ„æºç‚¹"""
    id: int
    x: int
    y: int
    resource_type: str  # "food" æˆ– "material"
    amount: float
    max_amount: float
    is_depleted: bool = False

@dataclass
class Tool:
    """å·¥å…·"""
    id: str
    name: str
    tool_type: str
    efficiency: float
    material_cost: int
    development_time: int
    developer_id: str
    known_by: List[str]

@dataclass
class Individual:
    """AIä¸ªä½“"""
    id: str
    x: int
    y: int
    intelligence: int
    physical: int
    perception: int
    age: int = 0
    health: int = 100
    hunger: int = 0
    fear: float = 0.0
    curiosity: float = 0.0
    cooperation: float = 0.0
    aggression: float = 0.0
    carried_food: int = 0
    carried_materials: int = 0
    current_tool: Optional[str] = None
    has_house: bool = False
    known_tools: List[str] = None
    memory: List[str] = None
    social_connections: Dict[str, float] = None
    
    def __post_init__(self):
        if self.known_tools is None:
            self.known_tools = []
        if self.memory is None:
            self.memory = []
        if self.social_connections is None:
            self.social_connections = {}

class MiniAIWorld:
    """è¿·ä½ ç‰ˆAIä¸–ç•Œæ¨¡æ‹Ÿç³»ç»Ÿ"""
    
    def __init__(self):
        # ä¸–ç•Œå‚æ•°
        self.world_size = (500, 500)
        self.max_resources = 200
        self.initial_population = 20
        self.current_day = 0
        self.simulation_running = False
        self.simulation_paused = False
        self.simulation_speed = 1.0
        
        # ç¹æ®–å‚æ•°ï¼ˆæé«˜æ¦‚ç‡å’ŒèŒƒå›´ï¼‰
        self.reproduction_probability = 0.15  # ä»0.05æé«˜åˆ°0.15
        self.reproduction_range = 100  # ç¹æ®–èŒƒå›´
        
        # æ•°æ®å­˜å‚¨
        self.data_dir = "mini_world_data"
        os.makedirs(self.data_dir, exist_ok=True)
        
        # ä¸–ç•ŒçŠ¶æ€
        self.individuals: List[Individual] = []
        self.resources: List[Resource] = []
        self.tools: Dict[str, Tool] = {}
        self.houses = []
        self.messages = []
        self.death_log = []
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'population': [],
            'tools_created': 0,
            'resources_collected': 0,
            'communications': 0,
            'deaths': 0,
            'births': 0
        }
        
        # åˆå§‹åŒ–GUI
        self._setup_gui()
        
        # åˆå§‹åŒ–ä¸–ç•Œ
        self._initialize_world()
    
    def _setup_gui(self):
        """è®¾ç½®å›¾å½¢ç”¨æˆ·ç•Œé¢"""
        self.root = tk.Tk()
        self.root.title("AIä¸–ç•Œæ¨¡æ‹Ÿç³»ç»Ÿ v2.0")
        self.root.geometry("1200x800")
        
        # åˆ›å»ºä¸»æ¡†æ¶
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # æ§åˆ¶é¢æ¿
        control_frame = ttk.LabelFrame(main_frame, text="æ§åˆ¶é¢æ¿", padding="10")
        control_frame.pack(fill=tk.X, pady=5)
        
        # ç¬¬ä¸€è¡Œï¼šåŸºæœ¬æ§åˆ¶
        btn_frame1 = ttk.Frame(control_frame)
        btn_frame1.pack(fill=tk.X, pady=5)
        
        self.start_btn = ttk.Button(btn_frame1, text="å¼€å§‹æ¨¡æ‹Ÿ", command=self.start_simulation)
        self.start_btn.pack(side=tk.LEFT, padx=5)
        
        self.pause_btn = ttk.Button(btn_frame1, text="æš‚åœ", command=self.pause_simulation, state="disabled")
        self.pause_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = ttk.Button(btn_frame1, text="åœæ­¢", command=self.stop_simulation, state="disabled")
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        # ä¸–ç•Œç®¡ç†æŒ‰é’®
        self.new_world_btn = ttk.Button(btn_frame1, text="æ–°å»ºä¸–ç•Œ", command=self.new_world)
        self.new_world_btn.pack(side=tk.LEFT, padx=5)
        
        self.overwrite_btn = ttk.Button(btn_frame1, text="é‡ç½®ä¸–ç•Œ", command=self.overwrite_world)
        self.overwrite_btn.pack(side=tk.LEFT, padx=5)
        
        # ç¬¬äºŒè¡Œï¼šå‚æ•°è°ƒæ•´
        btn_frame2 = ttk.Frame(control_frame)
        btn_frame2.pack(fill=tk.X, pady=5)
        
        # äººå£è°ƒæ•´
        ttk.Label(btn_frame2, text="äººå£è°ƒæ•´:").pack(side=tk.LEFT, padx=(0, 5))
        
        self.add_pop_btn = ttk.Button(btn_frame2, text="å¢åŠ äººå£", command=self.add_population)
        self.add_pop_btn.pack(side=tk.LEFT, padx=2)
        
        self.remove_pop_btn = ttk.Button(btn_frame2, text="å‡å°‘äººå£", command=self.remove_population)
        self.remove_pop_btn.pack(side=tk.LEFT, padx=2)
        
        self.set_pop_btn = ttk.Button(btn_frame2, text="è®¾ç½®äººå£", command=self.set_population)
        self.set_pop_btn.pack(side=tk.LEFT, padx=2)
        
        # ç¹æ®–å‚æ•°è°ƒæ•´
        ttk.Label(btn_frame2, text="ç¹æ®–æ¦‚ç‡:").pack(side=tk.LEFT, padx=(20, 5))
        self.reproduction_var = tk.DoubleVar(value=self.reproduction_probability)
        repro_scale = ttk.Scale(btn_frame2, from_=0.01, to=0.5, variable=self.reproduction_var,
                               orient=tk.HORIZONTAL, command=self._on_reproduction_change)
        repro_scale.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.repro_label = ttk.Label(btn_frame2, text=f"{self.reproduction_probability:.2f}")
        self.repro_label.pack(side=tk.LEFT, padx=5)
        
        # ç¬¬ä¸‰è¡Œï¼šé€Ÿåº¦æ§åˆ¶
        btn_frame3 = ttk.Frame(control_frame)
        btn_frame3.pack(fill=tk.X, pady=5)
        
        ttk.Label(btn_frame3, text="æ¨¡æ‹Ÿé€Ÿåº¦:").pack(side=tk.LEFT)
        self.speed_var = tk.DoubleVar(value=1.0)
        speed_scale = ttk.Scale(btn_frame3, from_=0.1, to=5.0, variable=self.speed_var, 
                               orient=tk.HORIZONTAL, command=self._on_speed_change)
        speed_scale.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.speed_label = ttk.Label(btn_frame3, text="1.0x")
        self.speed_label.pack(side=tk.LEFT, padx=5)
        
        # ä¿å­˜æŒ‰é’®
        self.save_btn = ttk.Button(btn_frame3, text="ä¿å­˜çŠ¶æ€", command=self._save_world_state)
        self.save_btn.pack(side=tk.RIGHT, padx=5)
        
        # å¯è§†åŒ–åŒºåŸŸ
        viz_frame = ttk.Frame(main_frame)
        viz_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # å›¾è¡¨
        self._setup_charts(viz_frame)
        
        # çŠ¶æ€å’Œä¿¡æ¯åŒºåŸŸ
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=5)
        
        # çŠ¶æ€ä¿¡æ¯
        status_frame = ttk.LabelFrame(info_frame, text="å®æ—¶çŠ¶æ€", width=300)
        status_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        self.status_text = scrolledtext.ScrolledText(status_frame, height=8)
        self.status_text.pack(fill=tk.BOTH, expand=True)
        self.status_text.config(state=tk.DISABLED)
        
        # äº‹ä»¶æ—¥å¿—
        event_frame = ttk.LabelFrame(info_frame, text="äº‹ä»¶æ—¥å¿—", width=300)
        event_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.event_text = scrolledtext.ScrolledText(event_frame, height=8)
        self.event_text.pack(fill=tk.BOTH, expand=True)
        self.event_text.config(state=tk.DISABLED)
        
        # åº•éƒ¨çŠ¶æ€æ 
        self.status_var = tk.StringVar(value="å°±ç»ª")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(fill=tk.X, pady=5)
    
    def _setup_charts(self, parent):
        """è®¾ç½®å›¾è¡¨"""
        self.fig, ((self.ax1, self.ax2), (self.ax3, self.ax4)) = plt.subplots(2, 2, figsize=(10, 6))
        
        # è®¾ç½®å›¾è¡¨å­—ä½“
        for ax in [self.ax1, self.ax2, self.ax3, self.ax4]:
            ax.title.set_fontname(chinese_font)
            ax.xaxis.label.set_fontname(chinese_font)
            ax.yaxis.label.set_fontname(chinese_font)
        
        # äººå£å›¾è¡¨
        self.ax1.set_title('äººå£è¶‹åŠ¿')
        self.ax1.set_xlabel('å¤©æ•°')
        self.ax1.set_ylabel('äººå£æ•°é‡')
        self.population_line, = self.ax1.plot([], [], 'b-', linewidth=2)
        self.ax1.grid(True, alpha=0.3)
        
        # å·¥å…·å›¾è¡¨
        self.ax2.set_title('å·¥å…·å‘å±•')
        self.ax2.set_xlabel('å¤©æ•°')
        self.ax2.set_ylabel('å·¥å…·æ•°é‡')
        self.tools_line, = self.ax2.plot([], [], 'g-', linewidth=2)
        self.ax2.grid(True, alpha=0.3)
        
        # èµ„æºå›¾è¡¨
        self.ax3.set_title('èµ„æºä½¿ç”¨')
        self.ax3.set_xlabel('å¤©æ•°')
        self.ax3.set_ylabel('èµ„æºæ•°é‡')
        self.food_line, = self.ax3.plot([], [], 'orange', linewidth=2, label='é£Ÿç‰©')
        self.material_line, = self.ax3.plot([], [], 'brown', linewidth=2, label='ææ–™')
        self.ax3.legend(prop={'family': chinese_font})
        self.ax3.grid(True, alpha=0.3)
        
        # ç¤¾ä¼šæ´»åŠ¨å›¾è¡¨
        self.ax4.set_title('ç¤¾ä¼šæ´»åŠ¨')
        self.ax4.set_xlabel('å¤©æ•°')
        self.ax4.set_ylabel('äº¤æµæ¬¡æ•°')
        self.comm_line, = self.ax4.plot([], [], 'purple', linewidth=2, label='äº¤æµ')
        self.ax4.legend(prop={'family': chinese_font})
        self.ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        self.canvas = FigureCanvasTkAgg(self.fig, parent)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
    
    def _initialize_world(self):
        """åˆå§‹åŒ–ä¸–ç•Œ"""
        # ç”Ÿæˆèµ„æº
        self._generate_resources()
        
        # ç”Ÿæˆåˆå§‹ä¸ªä½“
        self._generate_initial_individuals()
        
        # æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        self._update_status_display()
        
        self._add_event("ä¸–ç•Œåˆå§‹åŒ–å®Œæˆ")
        self._add_event(f"åˆå§‹äººå£: {self.initial_population}")
        self._add_event(f"ç¹æ®–æ¦‚ç‡: {self.reproduction_probability:.2f}")
        self._add_event(f"ç¹æ®–èŒƒå›´: {self.reproduction_range}")
    
    def _generate_resources(self):
        """ç”Ÿæˆèµ„æºç‚¹"""
        self.resources.clear()
        resource_id = 0
        for _ in range(self.max_resources // 2):
            x = random.randint(0, self.world_size[0])
            y = random.randint(0, self.world_size[1])
            resource_type = "food" if random.random() > 0.5 else "material"
            amount = random.randint(20, 100)
            
            self.resources.append(Resource(
                id=resource_id,
                x=x, y=y,
                resource_type=resource_type,
                amount=amount,
                max_amount=amount
            ))
            resource_id += 1
    
    def _generate_initial_individuals(self):
        """ç”Ÿæˆåˆå§‹ä¸ªä½“"""
        self.individuals.clear()
        for i in range(self.initial_population):
            x = random.randint(0, self.world_size[0])
            y = random.randint(0, self.world_size[1])
            
            individual = Individual(
                id=f"{i+1}.{random.randint(30,90)}.{random.randint(40,85)}.{random.randint(35,80)}",
                x=x, y=y,
                intelligence=random.randint(30, 90),
                physical=random.randint(40, 85),
                perception=random.randint(35, 80),
                curiosity=random.random(),
                cooperation=random.random(),
                aggression=random.random() * 0.3  # åˆå§‹æ”»å‡»æ€§è¾ƒä½
            )
            
            # ç»™äºˆåˆå§‹èµ„æº
            individual.carried_food = random.randint(10, 30)
            individual.carried_materials = random.randint(5, 15)
            
            self.individuals.append(individual)
    
    def _on_speed_change(self, value):
        """é€Ÿåº¦æ”¹å˜å›è°ƒ"""
        self.simulation_speed = float(value)
        self.speed_label.config(text=f"{self.simulation_speed:.1f}x")
    
    def _on_reproduction_change(self, value):
        """ç¹æ®–æ¦‚ç‡æ”¹å˜å›è°ƒ"""
        self.reproduction_probability = float(value)
        self.repro_label.config(text=f"{self.reproduction_probability:.2f}")
    
    def new_world(self):
        """æ–°å»ºä¸–ç•Œ"""
        if self.simulation_running:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœæ­¢æ¨¡æ‹Ÿå†æ–°å»ºä¸–ç•Œ")
            return
        
        result = messagebox.askyesno("æ–°å»ºä¸–ç•Œ", "è¿™å°†æ¸…é™¤å½“å‰ä¸–ç•Œæ‰€æœ‰æ•°æ®å¹¶åˆ›å»ºæ–°ä¸–ç•Œï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ")
        if result:
            # é‡ç½®æ‰€æœ‰çŠ¶æ€
            self.current_day = 0
            self.individuals.clear()
            self.resources.clear()
            self.tools.clear()
            self.houses.clear()
            self.messages.clear()
            self.death_log.clear()
            
            # é‡ç½®ç»Ÿè®¡
            self.stats = {
                'population': [],
                'tools_created': 0,
                'resources_collected': 0,
                'communications': 0,
                'deaths': 0,
                'births': 0
            }
            
            # é‡æ–°åˆå§‹åŒ–
            self._initialize_world()
            
            # æ¸…é™¤äº‹ä»¶æ—¥å¿—
            self.event_text.config(state=tk.NORMAL)
            self.event_text.delete(1.0, tk.END)
            self.event_text.config(state=tk.DISABLED)
            
            # é‡ç½®å›¾è¡¨
            self._update_charts()
            
            self._add_event("ğŸ†• æ–°ä¸–ç•Œåˆ›å»ºå®Œæˆï¼")
            self.status_var.set("æ–°ä¸–ç•Œå·²åˆ›å»º")
    
    def overwrite_world(self):
        """è¦†ç›–å½“å‰ä¸–ç•Œï¼ˆä¿ç•™ä¸ªä½“ä½†é‡ç½®çŠ¶æ€ï¼‰"""
        if self.simulation_running:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœæ­¢æ¨¡æ‹Ÿå†è¦†ç›–ä¸–ç•Œ")
            return
        
        result = messagebox.askyesno("è¦†ç›–ä¸–ç•Œ", "è¿™å°†é‡ç½®ä¸–ç•ŒçŠ¶æ€ä½†ä¿ç•™ç°æœ‰ä¸ªä½“ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ")
        if result:
            # å¤‡ä»½å½“å‰ä¸ªä½“
            current_individuals = self.individuals.copy()
            
            # é‡ç½®ä¸–ç•ŒçŠ¶æ€
            self.current_day = 0
            self.individuals.clear()
            self.resources.clear()
            self.tools.clear()
            self.houses.clear()
            self.messages.clear()
            self.death_log.clear()
            
            # é‡ç½®ç»Ÿè®¡ä½†ä¿ç•™äººå£å†å²
            pop_history = self.stats['population'][-1] if self.stats['population'] else 0
            self.stats = {
                'population': [pop_history] if pop_history > 0 else [],
                'tools_created': 0,
                'resources_collected': 0,
                'communications': 0,
                'deaths': 0,
                'births': 0
            }
            
            # é‡æ–°ç”Ÿæˆèµ„æº
            self._generate_resources()
            
            # æ¢å¤ä¸ªä½“ä½†é‡ç½®çŠ¶æ€
            for individual in current_individuals:
                individual.age = 0
                individual.health = 100
                individual.hunger = 0
                individual.carried_food = random.randint(10, 30)
                individual.carried_materials = random.randint(5, 15)
                individual.has_house = False
                individual.current_tool = None
                # ä¿ç•™å·²çŸ¥å·¥å…·ä½†æ¸…é™¤å…·ä½“å·¥å…·å¯¹è±¡ï¼ˆå°†åœ¨å·¥å…·é‡æ–°ç”Ÿæˆæ—¶é‡å»ºï¼‰
                individual.known_tools = []
                
                self.individuals.append(individual)
            
            # æ›´æ–°æ˜¾ç¤º
            self._update_status_display()
            self._update_charts()
            
            self._add_event("ğŸ”„ ä¸–ç•ŒçŠ¶æ€å·²è¦†ç›–é‡ç½®")
            self._add_event(f"ä¿ç•™ä¸ªä½“æ•°é‡: {len(self.individuals)}")
            self.status_var.set("ä¸–ç•Œå·²è¦†ç›–é‡ç½®")
    
    def add_population(self):
        """å¢åŠ äººå£"""
        if self.simulation_running:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœæ­¢æ¨¡æ‹Ÿå†è°ƒæ•´äººå£")
            return
        
        count = simpledialog.askinteger("å¢åŠ äººå£", "è¯·è¾“å…¥è¦å¢åŠ çš„äººå£æ•°é‡:", 
                                          initialvalue=5, minvalue=1, maxvalue=100)
        if count:
            self._create_individuals(count)
            self._add_event(f"â• å¢åŠ äº† {count} ä¸ªæ–°ä¸ªä½“")
            self._update_status_display()
    
    def remove_population(self):
        """å‡å°‘äººå£"""
        if self.simulation_running:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœæ­¢æ¨¡æ‹Ÿå†è°ƒæ•´äººå£")
            return
        
        if len(self.individuals) <= 1:
            messagebox.showwarning("è­¦å‘Š", "è‡³å°‘éœ€è¦ä¿ç•™1ä¸ªä¸ªä½“")
            return
        
        count = simpledialog.askinteger("å‡å°‘äººå£", "è¯·è¾“å…¥è¦å‡å°‘çš„äººå£æ•°é‡:", 
                                          initialvalue=min(5, len(self.individuals)-1), 
                                          minvalue=1, maxvalue=len(self.individuals)-1)
        if count:
            # éšæœºç§»é™¤ä¸ªä½“
            to_remove = random.sample(self.individuals, count)
            for individual in to_remove:
                self.individuals.remove(individual)
            
            self._add_event(f"â– ç§»é™¤äº† {count} ä¸ªä¸ªä½“")
            self._update_status_display()
    
    def set_population(self):
        """è®¾ç½®ç‰¹å®šäººå£æ•°é‡"""
        if self.simulation_running:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœæ­¢æ¨¡æ‹Ÿå†è°ƒæ•´äººå£")
            return
        
        target_pop = simpledialog.askinteger("è®¾ç½®äººå£", "è¯·è¾“å…¥ç›®æ ‡äººå£æ•°é‡:", 
                                               initialvalue=len(self.individuals), 
                                               minvalue=1, maxvalue=1000)
        if target_pop is not None:
            current_pop = len(self.individuals)
            if target_pop > current_pop:
                # éœ€è¦å¢åŠ äººå£
                self._create_individuals(target_pop - current_pop)
                self._add_event(f"ğŸ¯ äººå£è®¾ç½®ä¸º {target_pop} (å¢åŠ äº† {target_pop - current_pop} ä¸ªä¸ªä½“)")
            elif target_pop < current_pop:
                # éœ€è¦å‡å°‘äººå£
                to_remove = random.sample(self.individuals, current_pop - target_pop)
                for individual in to_remove:
                    self.individuals.remove(individual)
                self._add_event(f"ğŸ¯ äººå£è®¾ç½®ä¸º {target_pop} (ç§»é™¤äº† {current_pop - target_pop} ä¸ªä¸ªä½“)")
            else:
                self._add_event(f"ğŸ¯ äººå£ä¿æŒä¸º {target_pop}")
            
            self._update_status_display()
    
    def _create_individuals(self, count):
        """åˆ›å»ºæŒ‡å®šæ•°é‡çš„æ–°ä¸ªä½“"""
        for i in range(count):
            x = random.randint(0, self.world_size[0])
            y = random.randint(0, self.world_size[1])
            
            individual = Individual(
                id=f"{len(self.individuals)+1}.{random.randint(30,90)}.{random.randint(40,85)}.{random.randint(35,80)}",
                x=x, y=y,
                intelligence=random.randint(30, 90),
                physical=random.randint(40, 85),
                perception=random.randint(35, 80),
                curiosity=random.random(),
                cooperation=random.random(),
                aggression=random.random() * 0.3
            )
            
            # ç»™äºˆåˆå§‹èµ„æº
            individual.carried_food = random.randint(10, 30)
            individual.carried_materials = random.randint(5, 15)
            
            self.individuals.append(individual)
    
    def start_simulation(self):
        """å¼€å§‹æ¨¡æ‹Ÿ"""
        if self.simulation_running:
            return
        
        self.simulation_running = True
        self.simulation_paused = False
        
        self.start_btn.config(state="disabled")
        self.pause_btn.config(state="normal")
        self.stop_btn.config(state="normal")
        
        self.status_var.set("æ¨¡æ‹Ÿè¿è¡Œä¸­...")
        self._add_event("æ¨¡æ‹Ÿå¼€å§‹")
        
        # å¯åŠ¨æ¨¡æ‹Ÿçº¿ç¨‹
        self.simulation_thread = threading.Thread(target=self._simulation_loop, daemon=True)
        self.simulation_thread.start()
    
    def pause_simulation(self):
        """æš‚åœ/ç»§ç»­æ¨¡æ‹Ÿ"""
        self.simulation_paused = not self.simulation_paused
        
        if self.simulation_paused:
            self.pause_btn.config(text="ç»§ç»­")
            self.status_var.set("æ¨¡æ‹Ÿå·²æš‚åœ")
            self._add_event("æ¨¡æ‹Ÿæš‚åœ")
        else:
            self.pause_btn.config(text="æš‚åœ")
            self.status_var.set("æ¨¡æ‹Ÿè¿è¡Œä¸­...")
            self._add_event("æ¨¡æ‹Ÿç»§ç»­")
    
    def stop_simulation(self):
        """åœæ­¢æ¨¡æ‹Ÿ"""
        self.simulation_running = False
        self.simulation_paused = False
        
        self.start_btn.config(state="normal")
        self.pause_btn.config(state="disabled")
        self.stop_btn.config(state="disabled")
        self.pause_btn.config(text="æš‚åœ")
        
        self.status_var.set("æ¨¡æ‹Ÿå·²åœæ­¢")
        self._add_event("æ¨¡æ‹Ÿåœæ­¢")
        self._save_world_state()
    
    def _simulation_loop(self):
        """æ¨¡æ‹Ÿå¾ªç¯"""
        while self.simulation_running:
            if not self.simulation_paused:
                self._simulate_day()
                
                # æ›´æ–°GUI
                self.root.after(0, self._update_display)
                
                # æ ¹æ®é€Ÿåº¦è°ƒæ•´
                time.sleep(1.0 / self.simulation_speed)
            else:
                time.sleep(0.1)
    
    def _simulate_day(self):
        """æ¨¡æ‹Ÿä¸€å¤©"""
        self.current_day += 1
        
        # æ›´æ–°ä¸ªä½“çŠ¶æ€
        self._update_individuals()
        
        # ä¸ªä½“å†³ç­–å’Œè¡Œä¸º
        self._process_individual_actions()
        
        # å¤„ç†ç¹æ®–ï¼ˆä½¿ç”¨æé«˜åçš„æ¦‚ç‡ï¼‰
        self._process_reproduction()
        
        # å¤„ç†æ­»äº¡
        self._process_deaths()
        
        # èµ„æºå†ç”Ÿ
        self._regenerate_resources()
        
        # å·¥å…·çŸ¥è¯†ä¼ æ’­
        self._spread_tool_knowledge()
        
        # æ”¶é›†ç»Ÿè®¡ä¿¡æ¯
        self._collect_statistics()
        
        # å®šæœŸä¿å­˜
        if self.current_day % 10 == 0:
            self._save_world_state()
    
    def _update_individuals(self):
        """æ›´æ–°ä¸ªä½“çŠ¶æ€"""
        for individual in self.individuals[:]:  # ä½¿ç”¨åˆ‡ç‰‡é¿å…ä¿®æ”¹é—®é¢˜
            # å¹´é¾„å¢é•¿
            individual.age += 1
            
            # é¥¥é¥¿å¢åŠ 
            individual.hunger += random.randint(1, 3)
            
            # å¥åº·è¡°å‡
            if individual.hunger > 50:
                individual.health -= 2
            elif individual.hunger > 80:
                individual.health -= 5
            
            # ä½å®…åŠ æˆ
            if individual.has_house:
                individual.health += 1
                individual.hunger -= 1
            
            # é™åˆ¶èŒƒå›´
            individual.health = max(0, min(100, individual.health))
            individual.hunger = max(0, min(100, individual.hunger))
    
    def _process_individual_actions(self):
        """å¤„ç†ä¸ªä½“è¡Œä¸º"""
        random.shuffle(self.individuals)  # éšæœºé¡ºåºå¤„ç†
        
        for individual in self.individuals:
            if individual.health <= 0:
                continue
                
            # å†³ç­–ä¼˜å…ˆçº§
            action = self._choose_action(individual)
            self._execute_action(individual, action)
    
    def _choose_action(self, individual: Individual) -> str:
        """é€‰æ‹©è¡Œä¸º"""
        # ç´§æ€¥æƒ…å†µ
        if individual.health < 20:
            return "rest"
        if individual.hunger > 80:
            return "gather_food"
        
        # åŸºäºéœ€æ±‚å’Œæ€§æ ¼çš„å†³ç­–
        weights = {
            "gather_food": max(0, individual.hunger - 30) * (1 - individual.curiosity),
            "gather_materials": (100 - individual.hunger) * 0.5 * individual.curiosity,
            "develop_tool": individual.intelligence * 0.01 * individual.curiosity,
            "communicate": individual.cooperation * 50,
            "build_house": (individual.carried_materials / 50) * (1 - individual.has_house) * 30,
            "rest": max(0, 80 - individual.health) * 2
        }
        
        # éšæœºé€‰æ‹©åŠ æƒè¡Œä¸º
        actions, probs = zip(*weights.items())
        total = sum(probs)
        if total == 0:
            return "explore"
        
        r = random.uniform(0, total)
        cumulative = 0
        for action, prob in zip(actions, probs):
            cumulative += prob
            if r <= cumulative:
                return action
        
        return "explore"
    
    def _execute_action(self, individual: Individual, action: str):
        """æ‰§è¡Œè¡Œä¸º"""
        if action == "gather_food":
            self._gather_resource(individual, "food")
        elif action == "gather_materials":
            self._gather_resource(individual, "material")
        elif action == "develop_tool":
            self._develop_tool(individual)
        elif action == "communicate":
            self._communicate(individual)
        elif action == "build_house":
            self._build_house(individual)
        elif action == "rest":
            individual.health += 5
        else:  # explore
            self._move_individual(individual)
    
    def _gather_resource(self, individual: Individual, resource_type: str):
        """é‡‡é›†èµ„æº"""
        # å¯»æ‰¾æœ€è¿‘çš„èµ„æº
        nearest_resource = None
        min_distance = float('inf')
        
        for resource in self.resources:
            if resource.resource_type == resource_type and not resource.is_depleted:
                distance = self._calculate_distance(individual.x, individual.y, resource.x, resource.y)
                if distance < min_distance and distance < individual.perception:
                    min_distance = distance
                    nearest_resource = resource
        
        if nearest_resource:
            # ç§»åŠ¨åˆ°èµ„æºç‚¹
            individual.x, individual.y = self._move_towards(
                individual.x, individual.y, nearest_resource.x, nearest_resource.y, 10
            )
            
            # é‡‡é›†èµ„æº
            gather_amount = 5  # åŸºç¡€é‡‡é›†é‡
            
            # å·¥å…·åŠ æˆ
            if individual.current_tool and individual.current_tool in self.tools:
                tool = self.tools[individual.current_tool]
                if tool.tool_type == resource_type or tool.tool_type == "universal":
                    gather_amount *= (1 + tool.efficiency)
            
            actual_gather = min(gather_amount, nearest_resource.amount)
            nearest_resource.amount -= actual_gather
            
            if resource_type == "food":
                individual.carried_food += actual_gather
                individual.hunger = max(0, individual.hunger - actual_gather * 0.5)
            else:
                individual.carried_materials += actual_gather
            
            if nearest_resource.amount <= 0:
                nearest_resource.is_depleted = True
            
            self.stats['resources_collected'] += actual_gather
            
            # è®°å½•äº‹ä»¶
            if random.random() < 0.1:  # 10%æ¦‚ç‡è®°å½•
                self._add_event(f"{individual.id} é‡‡é›†äº†{actual_gather:.1f} {resource_type}")
    
    def _develop_tool(self, individual: Individual):
        """å¼€å‘å·¥å…·"""
        if individual.carried_materials < 10:
            return
        
        # æ¶ˆè€—ææ–™
        materials_used = min(individual.carried_materials, random.randint(5, 20))
        individual.carried_materials -= materials_used
        
        # è®¡ç®—æˆåŠŸç‡
        success_chance = individual.intelligence / 200 + individual.curiosity * 0.2
        development_time = max(1, 10 - individual.intelligence // 20)
        
        if random.random() < success_chance:
            # å·¥å…·å¼€å‘æˆåŠŸ
            tool_type = random.choice(["food", "material", "universal"])
            base_efficiency = 0.1  # åŸºç¡€æ•ˆç‡10%
            
            # åŸºäºå·²æœ‰çŸ¥è¯†æ”¹è¿› - ä¿®å¤ç©ºåˆ—è¡¨é—®é¢˜
            known_tools_of_type = [
                self.tools[tool_id].efficiency 
                for tool_id in individual.known_tools 
                if tool_id in self.tools and self.tools[tool_id].tool_type == tool_type
            ]
            
            if known_tools_of_type:
                best_efficiency = max(known_tools_of_type)
                base_efficiency = min(0.9, best_efficiency + random.uniform(0.05, 0.15))
            else:
                base_efficiency = random.uniform(0.1, 0.3)
            
            tool_id = f"T{len(self.tools)+1}.{tool_type}.{base_efficiency:.2f}.{materials_used}.{development_time}"
            
            tool = Tool(
                id=tool_id,
                name=f"å·¥å…·{len(self.tools)+1}",
                tool_type=tool_type,
                efficiency=base_efficiency,
                material_cost=materials_used,
                development_time=development_time,
                developer_id=individual.id,
                known_by=[individual.id]
            )
            
            self.tools[tool_id] = tool
            individual.known_tools.append(tool_id)
            individual.current_tool = tool_id
            
            self.stats['tools_created'] += 1
            self._add_event(f"ğŸ‰ {individual.id} å¼€å‘äº†æ–°å·¥å…·: {tool_id} (æ•ˆç‡: {base_efficiency:.1%})")
        
        else:
            # å¼€å‘å¤±è´¥
            self._add_event(f"{individual.id} å·¥å…·å¼€å‘å¤±è´¥ï¼ŒæŸå¤±äº†{materials_used}ææ–™")
    
    def _communicate(self, individual: Individual):
        """äº¤æµè¡Œä¸º"""
        # å¯»æ‰¾é™„è¿‘çš„ä¸ªä½“
        nearby_individuals = [
            other for other in self.individuals 
            if other != individual and 
            self._calculate_distance(individual.x, individual.y, other.x, other.y) < individual.perception
        ]
        
        if nearby_individuals:
            other = random.choice(nearby_individuals)
            
            # äº¤æµå†…å®¹
            message_types = [
                "é—®å€™", "èµ„æºä¿¡æ¯", "å·¥å…·ä¿¡æ¯", "å¨èƒè­¦å‘Š", "åˆä½œæè®®"
            ]
            message_type = random.choice(message_types)
            
            # è®°å½•æ¶ˆæ¯
            message = {
                'from': individual.id,
                'to': other.id,
                'type': message_type,
                'day': self.current_day
            }
            self.messages.append(message)
            
            self.stats['communications'] += 1
            
            # å·¥å…·çŸ¥è¯†ä¼ æ’­
            if (message_type == "å·¥å…·ä¿¡æ¯" and individual.known_tools and 
                random.random() < individual.cooperation):
                tool_id = random.choice(individual.known_tools)
                if tool_id not in other.known_tools:
                    other.known_tools.append(tool_id)
                    self.tools[tool_id].known_by.append(other.id)
            
            # ç¤¾äº¤å…³ç³»å»ºç«‹
            current_connection = individual.social_connections.get(other.id, 0)
            individual.social_connections[other.id] = current_connection + 0.1
            
            # è®°å½•äº‹ä»¶
            if random.random() < 0.3:
                self._add_event(f"ğŸ’¬ {individual.id} â†’ {other.id}: {message_type}")
    
    def _build_house(self, individual: Individual):
        """å»ºé€ ä½å®…"""
        if individual.has_house or individual.carried_materials < 30:
            return
        
        # æ¶ˆè€—ææ–™
        individual.carried_materials -= 30
        individual.has_house = True
        
        self.houses.append({
            'owner': individual.id,
            'location': (individual.x, individual.y),
            'build_day': self.current_day
        })
        
        self._add_event(f"ğŸ  {individual.id} å»ºé€ äº†ä½å®…")
    
    def _move_individual(self, individual: Individual):
        """ç§»åŠ¨ä¸ªä½“"""
        dx = random.randint(-10, 10)
        dy = random.randint(-10, 10)
        
        individual.x = max(0, min(self.world_size[0], individual.x + dx))
        individual.y = max(0, min(self.world_size[1], individual.y + dy))
    
    def _process_reproduction(self):
        """å¤„ç†ç¹æ®–ï¼ˆä½¿ç”¨æé«˜åçš„æ¦‚ç‡å’ŒèŒƒå›´ï¼‰"""
        if len(self.individuals) < 2:
            return
        
        # ä½¿ç”¨æé«˜åçš„ç¹æ®–æ¦‚ç‡
        if random.random() < self.reproduction_probability:
            # å¯»æ‰¾ç¬¦åˆæ¡ä»¶çš„çˆ¶æ¯å¯¹
            potential_parents = []
            for i, parent1 in enumerate(self.individuals):
                for parent2 in self.individuals[i+1:]:
                    distance = self._calculate_distance(parent1.x, parent1.y, parent2.x, parent2.y)
                    # ä½¿ç”¨æé«˜åçš„ç¹æ®–èŒƒå›´
                    if distance < self.reproduction_range:
                        potential_parents.append((parent1, parent2, distance))
            
            if potential_parents:
                # é€‰æ‹©è·ç¦»æœ€è¿‘çš„ä¸€å¯¹
                potential_parents.sort(key=lambda x: x[2])
                parents = potential_parents[0][:2]
                
                # ç¹æ®–æ¡ä»¶æ£€æŸ¥ï¼ˆæ¡ä»¶æ”¾å®½ï¼‰
                if (all(p.health > 50 for p in parents) and  # ä»60é™ä½åˆ°50
                    all(p.hunger < 60 for p in parents) and   # ä»50æé«˜åˆ°60
                    all(p.carried_food > 15 for p in parents)):  # ä»20é™ä½åˆ°15
                    
                    # åˆ›å»ºæ–°ä¸ªä½“
                    child_id = f"{len(self.individuals)+1}.{random.randint(30,90)}.{random.randint(40,85)}.{random.randint(35,80)}"
                    
                    child = Individual(
                        id=child_id,
                        x=(parents[0].x + parents[1].x) // 2,
                        y=(parents[0].y + parents[1].y) // 2,
                        intelligence=max(30, min(90, (parents[0].intelligence + parents[1].intelligence) // 2 + random.randint(-10, 10))),
                        physical=max(40, min(85, (parents[0].physical + parents[1].physical) // 2 + random.randint(-10, 10))),
                        perception=max(35, min(80, (parents[0].perception + parents[1].perception) // 2 + random.randint(-10, 10))),
                        curiosity=(parents[0].curiosity + parents[1].curiosity) / 2,
                        cooperation=(parents[0].cooperation + parents[1].cooperation) / 2,
                        aggression=(parents[0].aggression + parents[1].aggression) / 2,
                        carried_food=10,
                        carried_materials=5
                    )
                    
                    self.individuals.append(child)
                    self.stats['births'] += 1
                    self._add_event(f"ğŸ‘¶ æ–°ç”Ÿå‘½è¯ç”Ÿ: {child_id} (çˆ¶æ¯: {parents[0].id} & {parents[1].id})")
    
    def _process_deaths(self):
        """å¤„ç†æ­»äº¡"""
        dead_individuals = []
        
        for individual in self.individuals[:]:
            # æ­»äº¡æ¡ä»¶
            if (individual.health <= 0 or 
                individual.hunger >= 100 or 
                individual.age > 100 + individual.physical):
                
                dead_individuals.append(individual)
                self.individuals.remove(individual)
                
                # è®°å½•æ­»äº¡
                death_cause = "é¥¥é¥¿" if individual.hunger >= 100 else "è¡°è€" if individual.age > 100 else "å¥åº·"
                self.death_log.append({
                    'individual': individual.id,
                    'day': self.current_day,
                    'cause': death_cause,
                    'age': individual.age
                })
                
                self.stats['deaths'] += 1
                self._add_event(f"ğŸ’€ {individual.id} æ­»äº¡ (åŸå› : {death_cause}, å¹´é¾„: {individual.age})")
        
        return dead_individuals
    
    def _regenerate_resources(self):
        """èµ„æºå†ç”Ÿ"""
        for resource in self.resources:
            if resource.is_depleted and random.random() < 0.1:  # 10%æ¦‚ç‡å†ç”Ÿ
                resource.amount = resource.max_amount * 0.5
                resource.is_depleted = False
    
    def _spread_tool_knowledge(self):
        """ä¼ æ’­å·¥å…·çŸ¥è¯†"""
        for tool_id, tool in self.tools.items():
            if len(tool.known_by) > 0 and random.random() < 0.02:  # 2%æ¦‚ç‡ä¼ æ’­
                known_individual = random.choice(tool.known_by)
                known_ind_obj = next((ind for ind in self.individuals if ind.id == known_individual), None)
                
                if known_ind_obj:
                    # å¯»æ‰¾é™„è¿‘çš„æœªçŸ¥ä¸ªä½“
                    nearby_unknown = [
                        ind for ind in self.individuals 
                        if ind.id not in tool.known_by and
                        self._calculate_distance(known_ind_obj.x, known_ind_obj.y, ind.x, ind.y) < ind.perception
                    ]
                    
                    if nearby_unknown:
                        receiver = random.choice(nearby_unknown)
                        receiver.known_tools.append(tool_id)
                        tool.known_by.append(receiver.id)
    
    def _collect_statistics(self):
        """æ”¶é›†ç»Ÿè®¡ä¿¡æ¯"""
        self.stats['population'].append(len(self.individuals))
    
    def _calculate_distance(self, x1, y1, x2, y2):
        """è®¡ç®—è·ç¦»"""
        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
    
    def _move_towards(self, x1, y1, x2, y2, max_step):
        """å‘ç›®æ ‡ç§»åŠ¨"""
        dx, dy = x2 - x1, y2 - y1
        distance = self._calculate_distance(x1, y1, x2, y2)
        
        if distance <= max_step:
            return x2, y2
        
        ratio = max_step / distance
        return x1 + dx * ratio, y1 + dy * ratio
    
    def _add_event(self, event_text):
        """æ·»åŠ äº‹ä»¶"""
        self.event_text.config(state=tk.NORMAL)
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.event_text.insert(tk.END, f"[{timestamp}] {event_text}\n")
        self.event_text.see(tk.END)
        self.event_text.config(state=tk.DISABLED)
    
    def _update_status_display(self):
        """æ›´æ–°çŠ¶æ€æ˜¾ç¤º"""
        self.status_text.config(state=tk.NORMAL)
        self.status_text.delete(1.0, tk.END)
        
        self.status_text.insert(tk.END, f"=== ç¬¬ {self.current_day} å¤© ===\n\n")
        self.status_text.insert(tk.END, f"ğŸ‘¥ äººå£: {len(self.individuals)}\n")
        self.status_text.insert(tk.END, f"ğŸ› ï¸ å·¥å…·: {len(self.tools)}\n")
        self.status_text.insert(tk.END, f"ğŸ  ä½å®…: {len(self.houses)}\n")
        self.status_text.insert(tk.END, f"ğŸŒ¿ æ´»è·ƒèµ„æº: {len([r for r in self.resources if not r.is_depleted])}\n")
        self.status_text.insert(tk.END, f"ğŸ’¬ æ€»äº¤æµ: {self.stats['communications']}\n")
        self.status_text.insert(tk.END, f"ğŸ“Š å·¥å…·åˆ›é€ : {self.stats['tools_created']}\n")
        self.status_text.insert(tk.END, f"ğŸ‘¶ å‡ºç”Ÿ: {self.stats['births']} | ğŸ’€ æ­»äº¡: {self.stats['deaths']}\n\n")
        self.status_text.insert(tk.END, f"ğŸ¯ ç¹æ®–æ¦‚ç‡: {self.reproduction_probability:.2f}\n")
        self.status_text.insert(tk.END, f"ğŸ“ ç¹æ®–èŒƒå›´: {self.reproduction_range}\n\n")
        
        # æ˜¾ç¤ºæœ€è¿‘çš„å·¥å…·
        if self.tools:
            self.status_text.insert(tk.END, "æœ€è¿‘å¼€å‘çš„å·¥å…·:\n")
            recent_tools = list(self.tools.values())[-3:]
            for tool in recent_tools:
                self.status_text.insert(tk.END, f"  {tool.id} (çŸ¥æ™“è€…: {len(tool.known_by)})\n")
        
        self.status_text.config(state=tk.DISABLED)
    
    def _update_display(self):
        """æ›´æ–°æ˜¾ç¤º"""
        self._update_status_display()
        self._update_charts()
    
    def _update_charts(self):
        """æ›´æ–°å›¾è¡¨"""
        days = list(range(len(self.stats['population'])))
        
        if not days:
            return
            
        # æ›´æ–°äººå£å›¾è¡¨
        self.population_line.set_data(days, self.stats['population'])
        self.ax1.relim()
        self.ax1.autoscale_view()
        
        # æ›´æ–°å·¥å…·å›¾è¡¨
        tool_counts = [min(day, len(self.tools)) for day in days]
        self.tools_line.set_data(days, tool_counts)
        self.ax2.relim()
        self.ax2.autoscale_view()
        
        # æ›´æ–°èµ„æºå›¾è¡¨ï¼ˆæ¨¡æ‹Ÿæ•°æ®ï¼‰
        food_data = [p * 0.8 for p in self.stats['population']]
        material_data = [t * 1.2 for t in tool_counts]
        self.food_line.set_data(days, food_data)
        self.material_line.set_data(days, material_data)
        self.ax3.relim()
        self.ax3.autoscale_view()
        
        # æ›´æ–°äº¤æµå›¾è¡¨
        comm_data = [min(day * 2, self.stats['communications']) for day in days]
        self.comm_line.set_data(days, comm_data)
        self.ax4.relim()
        self.ax4.autoscale_view()
        
        self.canvas.draw()
    
    def _save_world_state(self):
        """ä¿å­˜ä¸–ç•ŒçŠ¶æ€"""
        try:
            state = {
                'current_day': self.current_day,
                'population': len(self.individuals),
                'tools_count': len(self.tools),
                'houses_count': len(self.houses),
                'reproduction_probability': self.reproduction_probability,
                'reproduction_range': self.reproduction_range,
                'timestamp': datetime.now().isoformat()
            }
            
            # ä¿å­˜å·¥å…·æ•°æ®
            tools_data = {tool_id: {
                'name': tool.name,
                'type': tool.tool_type,
                'efficiency': tool.efficiency,
                'known_by': tool.known_by
            } for tool_id, tool in self.tools.items()}
            
            # ä¿å­˜ä¸ªä½“æ•°æ®
            individuals_data = {ind.id: {
                'age': ind.age,
                'health': ind.health,
                'hunger': ind.hunger,
                'has_house': ind.has_house,
                'known_tools': ind.known_tools
            } for ind in self.individuals}
            
            # å†™å…¥æ–‡ä»¶
            with open(os.path.join(self.data_dir, f'world_state_{self.current_day:04d}.json'), 'w', encoding='utf-8') as f:
                json.dump({
                    'state': state,'çŠ¶æ€': çŠ¶æ€,
                    'tools': tools_data,â€œå·¥å…·â€ï¼šå·¥å…·æ•°æ®ï¼Œ
                    'individuals': individuals_data
                }, f, indent=2, ensure_ascii=False)
            
            self._add_event(f"ğŸ’¾ ç¬¬{self.current_day}å¤©çŠ¶æ€å·²ä¿å­˜")self._add_event(f"ç¬¬{self.current_day}å¤©çŠ¶æ€å·²ä¿å­˜")
            
        except Exception as e:
            self._add_event(f"âŒ ä¿å­˜å¤±è´¥: {str(e)}")
    
    def run(self):
        """è¿è¡Œæ¨¡æ‹Ÿç³»ç»Ÿ"""
        self.root.mainloop()

# å¯åŠ¨ç³»ç»Ÿ
if __name__ == "__main__":
    print("ğŸš€ å¯åŠ¨AIä¸–ç•Œæ¨¡æ‹Ÿç³»ç»Ÿ v2.0...")
    world = MiniAIWorld()
    world.run()ä¸–ç•Œ.è¿è¡Œ()
